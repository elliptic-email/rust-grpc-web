
mod proto {
    tonic::include_proto!("quotes");
}

use futures::StreamExt;
use std::{
    collections::HashMap,
    net::SocketAddr,
    net::TcpListener,
    pin::Pin,
    sync::{Arc, RwLock},
    time::Duration,
};
use tokio::io::AsyncReadExt;
use tokio::sync::broadcast::{channel, Sender};
use tokio_stream::{wrappers::BroadcastStream, Stream};
use tonic::{async_trait, body::BoxBody, transport::Channel, Code, Request, Response, Status};

// Implementation of the server trait generated by tonic
#[derive(Debug, Clone)]
struct ServerImpl {
    db: Arc<RwLock<HashMap<String, u32>>>,
    tx: Sender<proto::SubscribeReply>,
}

#[async_trait]
impl proto::quote_service_server::QuoteService for ServerImpl {
    async fn get_currencies(&self, request: Request<proto::CurrenciesRequest>) -> Result<Response<proto::CurrencyReply>, Status> {
        let reply = proto::CurrencyReply {
            iso_codes: vec!("BTC".into(), "ETH".into())
        };

        Ok(Response::new(reply))
    }

    type SubscribeStream =
        Pin<Box<dyn Stream<Item = Result<proto::SubscribeReply, Status>> + Send + Sync + 'static>>;

    async fn subscribe(
        &self,
        request: Request<proto::SubscribeRequest>,
    ) -> Result<Response<Self::SubscribeStream>, Status> {
        let proto::SubscribeRequest {} = request.into_inner();

        let rx = self.tx.subscribe();
        let stream = BroadcastStream::new(rx)
            .filter_map(|item| async move {
                // ignore receive errors
                item.ok()
            })
            .map(Ok);
        let stream: Self::SubscribeStream = Box::pin(stream);
        let res = Response::new(stream);

        Ok(res)
    }
}

fn main() {
    println!("Hello, world!");
}
