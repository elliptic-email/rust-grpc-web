
mod proto {
    tonic::include_proto!("quotes");
}

use futures::StreamExt;
use std::{
    pin::Pin,
};
use tokio::sync::broadcast::{channel, Sender};
use tokio_stream::{wrappers::BroadcastStream, Stream};
use tonic::{async_trait, Request, Response, Status};

// Implementation of the server trait generated by tonic
#[derive(Debug, Clone)]
struct ServerImpl {
    tx: Sender<proto::SubscribeReply>,
}

#[async_trait]
impl proto::quote_service_server::QuoteService for ServerImpl {
    async fn get_currencies(&self, _request: Request<proto::CurrenciesRequest>) -> Result<Response<proto::CurrencyReply>, Status> {
        let reply = proto::CurrencyReply {
            iso_codes: vec!("BTC".into(), "ETH".into())
        };

        Ok(Response::new(reply))
    }

    type SubscribeStream =
        Pin<Box<dyn Stream<Item = Result<proto::SubscribeReply, Status>> + Send + Sync + 'static>>;

    async fn subscribe(
        &self,
        request: Request<proto::SubscribeRequest>,
    ) -> Result<Response<Self::SubscribeStream>, Status> {
        let proto::SubscribeRequest {} = request.into_inner();

        let rx = self.tx.subscribe();
        let stream = BroadcastStream::new(rx)
            .filter_map(|item| async move {
                // ignore receive errors
                item.ok()
            })
            .map(Ok);
        let stream: Self::SubscribeStream = Box::pin(stream);
        let res = Response::new(stream);

        Ok(res)
    }
}

#[tokio::main]
async fn main() {
    let (tx, _rx) = channel(1024);
    let addr = "0.0.0.0:50051".parse().unwrap();

    // Build our tonic `Service`
    let service = proto::quote_service_server::QuoteServiceServer::new(ServerImpl { tx });


    tonic::transport::Server::builder()
        .add_service(service)
        .serve(addr)
        .await.unwrap();
}
